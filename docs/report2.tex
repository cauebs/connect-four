%-------------------------------------------------------------------------------
\documentclass{article}

%-------------------------------------------------------------------------------
% Packages
\usepackage{amsmath}
\usepackage[portuguese]{babel}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{minted}
\usepackage{xcolor}

%-------------------------------------------------------------------------------
% User-commands
\newcommand{\todo}[1]{{\color{red}{#1}}}

\newmintedfile{rust}{autogobble, xleftmargin=2em}
\newcommand{\rustinline}[1]{\mintinline{rust}{#1}}

%-------------------------------------------------------------------------------
% Project configs
\title{Relatório de I.A.: Gomoku, Parte 2}
\author{Cauê Baasch de Souza \\
        João Paulo Taylor Ienczak Zanette}
\date{\today}

%-------------------------------------------------------------------------------
\begin{document}
    \maketitle{}

    \section{Decisões de Projeto}

    \subsection{Geral}

    O programa foi escrito na linguagem Rust, separado em 8 arquivos:

    \begin{itemize}
        \item \texttt{ai.rs}: Contém a implementação do \textbf{``Smart Bot''},
            que representa a I.A. implementada com o algoritmo do
            \textit{minimax} com podas \textit{alpha-beta}.
        \item \texttt{axes.rs}: Contém a implementação de um iterador que itera
            pelos eixos do tabuleiro.
        \item \texttt{board.rs}: Contém a implementação do tabuleiro em si.
        \item \texttt{coordinates.rs}: Contém funções de parsing de coordenadas
            (para entrada do usuário).
        \item \texttt{game.rs}: Contém a implementação do jogo em si, com
            funcionalidades para interagir em uma partida (avançar turnos,
            simular o jogo até o fim\ldots).
        \item \texttt{main.rs}: Contém a execução principal do programa, com
            uma função de heurística para teste e a configuração de um jogo de
            exemplo.
        \item \texttt{players.rs}: Contém a implementação de alguns jogadores,
            como o ``Human'', que joga conforme a entrada do usuário, e o
            ``Random Bot'', que apenas seleciona uma célula aleatória livre.
        \item \texttt{tests.rs}: Contém os testes unitários para validar
            algumas implementações feitas, como: validar os algoritmos de
            detecção de vitória (se não consideram uma sequência de 5
            elementos, porém em linhas diferentes, como vitória, por exemplo).
    \end{itemize}

    \textit{OBS\@: Em Rust, quando não há ``;'' no último comando de um escopo,
    então aquele comando é o valor retornado pelo escopo.}

    \subsubsection{O jogo}

    O jogo foi estruturado considerando que fosse possível vincular duas
    implementações quaisquer de jogadores, desde que implementem uma função
    \rustinline{decide(self, board, last_move)}, em que \texttt{self} é
    o próprio jogador, \texttt{board} é o tabuleiro no momento em que o jogador
    irá decidir sua jogada, e \texttt{last\_move} é a última jogada feita (ou
    nenhuma, caso seja a primeira jogada). Isso é feito utilizando uma
    \textit{trait} (semelhante a interface) chamada ``Player'':

    \rustfile[firstline=11, lastline=17]{../src/players.rs}

    A partir disso, o jogo pode ser simulado de três formas: apenas um turno,
    ``$N$'' turnos ou até o fim (empate ou vitória). A criação de um jogo é
    dada definindo qual implementação será utilizada para os jogadores 1 e 2,
    como no exemplo abaixo:

    \rustfile[firstline=53, lastline=55]{../src/main.rs}

    \subsubsection{``Smart Bot'' e o \textit{minimax}}

    Em \texttt{ai.rs} se encontra a implementação da \rustinline{struct
    SmartBot}, que implementa a \rustinline{trait Player}, fazendo seu
    \rustinline{decide(...)} retornar a função ``minimax'':

    \rustfile[firstline=96, lastline=98]{../src/ai.rs}

    A função ``minimax'' é subdividida em uma outra função, ``minimax\_aux'',
    \todo{Mas essa parte o Cauê sabe melhor} \todo{AVANÇA NESSA CAVALA IMUNDA.}

    \subsection{Limitações}

    \todo{AVANÇA NESSA CAVALA IMUNDA.}

    \section{Principais Métodos}

    \todo{Provavelmente vai ficar embutido nos outros tópicos.}
    \todo{AVANÇA NESSA CAVALA IMUNDA.}

    \subsection{Utilidade e Heurística}

    Uma mesma função foi utilizada para Utilidade e Heurística. \todo{O
    resultado dessa função é apenas a diferença da pontuação do jogador atual
    com a do oponente para o tabuleiro dado}:

    \rustfile[firstline=25, lastline=25]{../src/main.rs}
    \begin{minted}{rust}
        ...
    \end{minted}
    \rustfile[firstline=44, lastline=46]{../src/main.rs}

    O cálculo da pontuação para o tabuleiro, dado um jogador, está definido em
    uma função interna à de heurística, em que, para cada caminho possível nos
    eixos (todas as horizontais, verticais e diagonais principais e
    secundárias), conta-se um \textit{streak} (sequência de casas que não
    estejam sendo ocupadas pelo oponente, limitando a até 5 elementos). Esse
    \textit{streak} então é elevado a uma constante arbitrária
    (\rustinline{SCORE_PER_MY_SPACE}). Sendo assim, sequências muito boas de
    \textit{streaks} geram pontuações muito altas. Quando o tamanho do
    \textit{streak} é 5, porém, a função imediatamente para retornando o maior
    número inteiro com sinal possível).

    \rustfile[firstline=26, lastline=42, samepage]{../src/main.rs}

    \todo{Tiz, descreve aqui bonitinho as heurísticas. AVANÇA NESSA CAVALA
    IMUNDA.}

    \subsection{Outros métodos}
\end{document}
